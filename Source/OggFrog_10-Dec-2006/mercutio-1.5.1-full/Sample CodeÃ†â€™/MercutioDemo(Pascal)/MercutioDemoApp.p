PROGRAM TestMDEFApp;	USES{$IFC UNDEFINED UseFakeMain}{$SETC UseFakeMain=FALSE}{$ENDC}		Traps, Types, OSUtils, Windows, ToolUtils, Memory, TextUtils, TextEdit, Fonts, PasLibIntf, Dialogs,		 Icons, Menus, Devices, QuickDraw,  Events, Resources, Appearance,{$IFC UseFakeMain}		DebugUtils, Mercutio, MercutioLog,{$ENDC}		MercutioAPI, PopupDialog;	CONST		appleMenuID = 300;		{ Resource ID of the Apple menu }		fileMenuID = 301;		{ Resource ID of the File menu }		editMenuID = 302;		{ Resource ID of the Edit menu }		keysMenuID = 303;		iconsMenuID = 304;		callbackMenuID = 305;		colorMenuID = 306;		xmnuMenuID = 307;		dynamicSubMenuID = 3;		modifiersMenuID = 4;				firstMenu = 300;		{ Res ID of first menu in menu bar }		lastLoadedMenu = 307; // 307;		{ Res ID of last menu in menu bar }		lastMenu = lastLoadedMenu+1; // 307;		{ Res ID of last menu in menu bar }		firstHierMenu = 1;		lastHierMenu = 8; //8;		kICONSize = 32;		kSICNSize = 16;		svAllLargeData = $000000ff;		svAllSmallData = $0000ff00;		addFolderIconID = 262;		addFoldersIconID = 263;		addFileIconID = 264;		addFilesIconID = 265;	TYPE		IconSelectorValue = LONGINT;	VAR		Finished: Boolean;				{ Set to true when were done	}		normalMenus: ARRAY[firstMenu..lastLoadedMenu] OF MenuHandle; { The menus in menu bar	}		hierMenus: ARRAY[firstHierMenu..lastHierMenu] OF MenuHandle; { The hidden menus	}		hMDEF: Handle;					{ required for PowerMenuKey }		theErr : OSErr;		h : MenuHandle;		useKeyGraphics:boolean;		theAddress : longint;		UPPforCallback : MercutioCallbackUPP;		UPPforMDEF : MenuDefUPP;				flyMenu, flyMenu2: MenuHandle;	PROCEDURE ToggleItem (theMenu: MenuHandle; item: Integer);		VAR			curMark: char;	BEGIN		GetItemMark(theMenu, item, curMark);		IF curMark = chr(noMark) THEN			CheckItem(theMenu, item, true) {check it on in menu}		ELSE			CheckItem(theMenu, item, false); {check it off in menu}	END;	PROCEDURE doAbout;	VAR		AboutRecord: DialogRecord;		{ the actual object		}		AboutDlog: DialogPtr;			{ a Pointer to my dialog	}		dummy: Integer;		CopyrightStr : Str255;	BEGIN		CopyrightStr := MDEF_GetCopyright(normalMenus[keysMenuID]);		AboutDlog := GetNewDialog(3000, @AboutRecord, Pointer(-1));		ParamText(CopyrightStr,CopyrightStr,'','');		ModalDialog(NIL, dummy);		CloseDialog(AboutDlog);	END;{------------------------- process the menu selection --------------------------}	PROCEDURE HandleMenu (CodeWord: LongInt);		VAR			menuNum: Integer;				{ Res ID of the menu Selected	}			itemNum: Integer;				{ The item number selected	}			nameHolder: Str255;				{ the name of the desk acc.	}			i, dummy: Integer;				{ standard loop variable + filler variable}			tempStr: Str255;			curSetting: boolean;			markChar: char;	BEGIN		menuNum := HiWrd(CodeWord);	{ get the menu number		}		itemNum := LoWrd(CodeWord);	{ get the item number		}		IF itemNum > 0 THEN			{ ok to Handle the menu?	}			BEGIN				CASE menuNum OF					appleMenuID: 						CASE itemNum OF							1:  								doAbout;							2:  BEGIN								END;							OTHERWISE BEGIN									GetMenuItemText(normalMenus[appleMenuID], itemNum, nameHolder);									dummy := OpenDeskAcc(nameHolder);								END;						END;					fileMenuID: 						CASE itemNum OF							1: BEGIN {debugStr('Doing popup dialog');}								doPopupDialog; END;							3: 								Finished := true;							OTHERWISE								ToggleItem(normalMenus[menuNum], itemNum);						END;					iconsMenuID:  BEGIN							IF itemNum = 6 THEN BEGIN	{ enable / disable toggle }									GetItemMark(normalMenus[menuNum], itemNum, markChar);									FOR i := 7 TO CountMItems(normalMenus[menuNum]) DO BEGIN											IF markChar = chr(0) THEN												EnableItem(normalMenus[menuNum], i)											ELSE												DisableItem(normalMenus[menuNum], i);										END;								END;							ToggleItem(normalMenus[menuNum], itemNum);						END;					keysMenuID:						CASE itemNum OF							5 : BEGIN									useKeyGraphics := NOT useKeyGraphics;									MDEF_SetKeyGraphicsPreference(normalMenus[menuNum], useKeyGraphics);									ToggleItem(normalMenus[menuNum], itemNum);																	END;							OTHERWISE								ToggleItem(normalMenus[menuNum], itemNum);							END;					callbackMenuID, colorMenuID, xmnuMenuID: 						IF itemNum <> 0 THEN							ToggleItem(normalMenus[menuNum], itemNum);					firstHierMenu..lastHierMenu: 						IF itemNum <> 0 THEN							ToggleItem(hierMenus[menuNum], itemNum);					OTHERWISE						IF itemNum <> 0 THEN							ToggleItem(flyMenu, itemNum);				END;						{ of case menuNum of		}			END;							{ of if CodeWord...		}		HiliteMenu(0);	END;								{ of process menu		}{------------------------------- Main event loop -------------------------------}	PROCEDURE MainEventLoop;		VAR			event: EventRecord;			{ Filled by Get next event	}			windowLoc: integer;			{ the mouse location		}			mouseLoc: Point;				{ the area it was in		}			theWindow: WindowPtr;			{ Dummy,cause we have no windows}			matchedItem: longint;			p1 : GrafPtr;	BEGIN		p1 := qd.thePort;				REPEAT							{ do this until we selected quit}			SystemTask;					{ Take care of desk accessories	}			IF GetNextEvent(everyEvent, event) THEN	{ if there was an event... then	}				CASE event.what OF			{ case out on the event type	}					mouseDown:				{ we had a mouse-down event	}						BEGIN							mouseLoc := event.where;	{ wheres the pesky mouse	}							windowLoc := FindWindow(mouseLoc, theWindow); { find out where }							CASE windowLoc OF	{ now case on the location	}								inMenuBar: 									HandleMenu(MenuSelect(mouseLoc)); { Handle the selection	}								inSysWindow: 									SystemClick(event, theWindow); {It was in a desk acc	}								OTHERWISE							END;						END;					keyDown, autoKey:			{ we had the user hit a key	}						BEGIN							matchedItem := MDEF_MenuKey(event.message, event.modifiers, normalMenus[keysMenuID]);							HandleMenu(matchedItem);						END;					OTHERWISE				END;			{ of case event.what...		}		UNTIL (Finished);	{ end of repeat statement	}	END;					{ of main event loop		}	PROCEDURE getModifiers (VAR theMods: integer);		TYPE			intAsMods = PACKED RECORD					b5, b6, b7: boolean;					control: boolean;					option: boolean;					capsLock: boolean;					shift: boolean;					command: boolean;					eventType: char;				END;		VAR			k: KeyMap;	BEGIN		theMods := 0;		GetKeys(k);		WITH intAsMods(theMods) DO BEGIN				control := k[$3B];				shift := k[$38];				option := k[$3A];				command := k[$37];				capsLock := k[$39];			END;	END;	PROCEDURE MyGetItemInfo (menuID: integer; previousModifiers: integer; VAR itemData: RichItemData);	{ This routine is used by the Callback menu to demonstrate the }	{ Mercutio callback mechanism. This routine is called for every }	{ item in the menu flagged as a "callback item" (in our case, }	{ with the Outline style bit). }	{}	{ In this example, we check the Shift and Option keys to }	{ determine what the text and icon of the menu item should }	{ be. }	{}	{ Note the "Dirty" parameter; if we don't change anything}	{ in the menuItem, this parameter should be false to}	{ avoid unnecessary redrawing (and flicker).}	{}		VAR			theErr: OSErr;			modifiers: integer;			timeStr, secondStr: Str255;			secs: longint;	BEGIN		getModifiers(modifiers);	{ get the user's current modifiers }		theErr := noErr;		IF itemData.itemID = 37 THEN BEGIN			CASE itemData.cbMsg OF				cbBasicDataOnlyMsg:  BEGIN						IF (BitAnd(modifiers, shiftKey) > 0) THEN BEGIN								itemData.flags.shiftKey := true;								IF (BitAnd(modifiers, optionKey) > 0) THEN BEGIN										itemData.itemStr := 'Add Folders…';										itemData.flags.optionKey := true;									END								ELSE BEGIN										itemData.itemStr := 'Add Folder…';									END;							END						ELSE BEGIN								IF (BitAnd(modifiers, optionKey) > 0) THEN BEGIN										itemData.itemStr := 'Add Files…';										itemData.flags.optionKey := true;									END								ELSE BEGIN										itemData.itemStr := 'Add File…';									END							END;						itemData.flags.hasIcon := true;						itemData.flags.changedByCallback := (modifiers <> previousModifiers);					END;				cbIconOnlyMsg:  BEGIN						IF (BitAnd(modifiers, shiftKey) > 0) THEN							IF (BitAnd(modifiers, optionKey) > 0) THEN								itemData.hIcon := Handle(GetCIcon(addFoldersIconID))							ELSE								itemData.hIcon := Handle(GetCIcon(addFolderIconID))						ELSE BEGIN								IF (BitAnd(modifiers, optionKey) > 0) THEN									itemData.hIcon := Handle(GetCIcon(addFilesIconID))								ELSE									itemData.hIcon := Handle(GetCIcon(addFileIconID));							END;						itemData.flags.hasIcon := true;						itemData.iconType := 'cicn';						itemData.flags.changedByCallback := (modifiers <> previousModifiers);					END;				cbGetLongestItemMsg:  BEGIN						itemData.itemStr := 'Add Folders…';						itemData.flags.shiftKey := true;						itemData.flags.optionKey := true;					END;				OTHERWISE BEGIN					END;			END;		END ELSE IF itemData.itemID = 38 THEN BEGIN				CASE itemData.cbMsg OF					cbBasicDataOnlyMsg:  BEGIN							GetDateTime(secs);							IUTimeString(secs, TRUE, timeStr);							NumToString(TickCount, secondStr);							itemData.itemStr := concat(timeStr, ' (', secondStr, ')');							itemData.flags.changedByCallback := true;						END;					cbIconOnlyMsg:  BEGIN						END;					cbGetLongestItemMsg:  BEGIN							itemData.itemStr := '9999999999999';						END;					OTHERWISE BEGIN						END;				END;			END;	END;{------------------------------ SetUp Everything -------------------------------}	PROCEDURE SetUpMenus;		TYPE			ShortPtr = ^integer;			LongPtr = ^longint;		VAR			index: integer;				{ used in a for loop		}			hRes: Handle;			dataPtr: Ptr;			prefs: MenuPrefsRec;			hIcon : CIconHandle;	BEGIN{$IFC UseFakeMain}{$IFC POWERPC}		UPPforMDEF := NewMenuDefProc(@MDEF);		hMDEF := NewEmptyHandle();		hMDEF^ := UPPforMDEF;{$ELSEC}		hRes := Get1Resource('MDEF', 19999);		IF ((hRes <> NIL) & (GetHandleSize(hRes) = 6)) THEN BEGIN				hLock(Handle(hRes));				dataPtr := hRes^;				ShortPtr(dataPtr)^ := $4EF9;				dataPtr := Pointer(ord4(dataPtr) + 2);				LongPtr(dataPtr)^ := longint(@MDEF);				hUnLock(Handle(hRes));				ChangedResource(hRes);				IF resError = noErr THEN					WriteResource(hRes);			END		ELSE			DebugStr("Couldn''t find the stub MDEF.");{$ENDC}		{$ENDC}						index := SizeOf(prefs);					{ *** load and install the menus *** }		FOR index := firstMenu TO lastLoadedMenu DO	{ loop for all menus in menu bar}			BEGIN				normalMenus[index] := GetMenu(index);	{ Get the next menu		}				{$IFC UseFakeMain}{$IFC POWERPC}				IF (longint(normalMenus[index]^^.menuProc) <> 0) THEN					knormalMenus[index]^^.menuProc := hMDEF;{$ENDC}{$ENDC}				IF index = appleMenuID THEN					AppendResMenu(normalMenus[appleMenuID], 'DRVR');	{ Add desk accessories		}				InsertMenu(normalMenus[index], 0);				CalcMenuSize(normalMenus[index]);			END;				FOR index := firstHierMenu TO lastHierMenu DO BEGIN				hierMenus[index] := GetMenu(index);				InsertMenu(hierMenus[index], -1);				CalcMenuSize(hierMenus[index]);			END;		flyMenu := newMenu(lastLoadedMenu+1, "OnTheFly");		AppendMenu(flyMenu,"Alpha");		AppendMenu(flyMenu,"Beta");		AppendMenu(flyMenu,"Delta");		AppendMenu(flyMenu,"Gamma");		AppendMenu(flyMenu,"Omega");		hRes := Get1Resource('MDEF', 19999);		flyMenu^^.menuProc := hRes;		InsertMenu(flyMenu,0);		CalcMenuSize(flyMenu);{		flyMenu2 := newMenu(lastLoadedMenu+2, "OnTheFly");		AppendMenu(flyMenu2,"Alpha");		setItemCmd(flyMenu2,1,'W');		AppendMenu(flyMenu2,"OmegaConstruction");		InsertMenu(flyMenu2,0);		CalcMenuSize(flyMenu2);}		{ by default, use text versions of PageUp, PageDown, etc.}		useKeyGraphics := FALSE;		MDEF_SetKeyGraphicsPreference(normalMenus[lastLoadedMenu], useKeyGraphics);		{ by default, make icons > 200 show up small (typically 16 x 16)		{ in our demo app, this is essentially all the icons }		{ comment this out if you want to try it out }		{ MDEF_SetSmallIconIDPreference(normalMenus[lastLoadedMenu], 200); }	{ *** setup the preferences for our menus *** }	{ This is where we determine which style bits are mapped to }	{ MDEF features. Most of the menus use Mercutio's default }	{ settings. These menus are the exceptions. }	{}	{ Feel free to play with these settings and see how }	{ the menus are affected.}	{}	{ Note that we could have stored all this information in an}	{ 'Xmnu' resource with the same ID as the menu, and avoided }	{ the hassle of setting these preferences programmatically. }	{ We do it this way to demonstrate the various features of}	{ the MDEF. }	{ *** set up the Color menu *** }	{		1. the Color menu uses an 'Xmnu' resource }	{ 		   to restore the Condense and Extend bits to their }	{		   regular functions (as style bits), and sets the }	{		   DEFAULT modifiers to Option-Command. This means }	{		   that key equivalents in this Menu need the Command }	{		   and Option keys held down, but all the style bits}	{		   are still free to be used as such. }	{}		WITH prefs DO BEGIN				optionKeyFlag.s := [];				shiftKeyFlag.s := [];				cmdKeyFlag.s := [];				controlKeyFlag.s := [];				isDynamicFlag.s := [];				forceNewGroupFlag.s := [];				useCallbackFlag.s := [];				requiredModifiers := cmdKey + optionKey;			END;		MDEF_SetMenuPrefs(normalMenus[colorMenuID], @prefs);	{ *** set up the Modifiers menu *** }	{}	{	2. the Modifiers menu demonstrates all four }	{	  modifier keys in action. Thus, we need}	{	  to use four style bits, which we }	{	  select and store below.}	{}		WITH prefs DO BEGIN				optionKeyFlag.s := [underline];				shiftKeyFlag.s := [extend];				cmdKeyFlag.s := [bold];				controlKeyFlag.s := [shadow];				isDynamicFlag.s := [];				forceNewGroupFlag.s := [];				useCallbackFlag.s := [outline];				requiredModifiers := 0;			END;		MDEF_SetMenuPrefs(hierMenus[modifiersMenuID], @prefs);		WITH prefs DO BEGIN				optionKeyFlag.s := [];				shiftKeyFlag.s := [italic];				cmdKeyFlag.s := [bold];				controlKeyFlag.s := [];				isDynamicFlag.s := [];				forceNewGroupFlag.s := [];				useCallbackFlag.s := [];				requiredModifiers := 0;			END;		MDEF_SetMenuPrefs(flyMenu, @prefs);	{ *** set up the Callback menu *** }	{ Note that we can make this call regardless of what MDEF we are using, }	{ because if an MDEF doesn't recognize a message (in our case, the }	{ SetCallback message), it simply ignores it.}	{}		WITH prefs DO BEGIN				optionKeyFlag.s := [condense];				shiftKeyFlag.s := [extend];				cmdKeyFlag.s := [];				controlKeyFlag.s := [];				isDynamicFlag.s := [outline];				forceNewGroupFlag.s := [italic];				useCallbackFlag.s := [underline];				requiredModifiers := cmdKey;			END;				UPPforCallback := NewMercutioCallback(@MyGetItemInfo);		MDEF_SetCallbackProc(normalMenus[callbackMenuID], UPPforCallback);		MDEF_SetMenuPrefs(normalMenus[callbackMenuID], @prefs);		WITH prefs DO BEGIN				optionKeyFlag.s := [condense];				shiftKeyFlag.s := [extend];				cmdKeyFlag.s := [];				controlKeyFlag.s := [];				isDynamicFlag.s := [outline];				forceNewGroupFlag.s := [italic];				useCallbackFlag.s := [];				requiredModifiers := cmdKey;			END;		MDEF_SetMenuPrefs(hierMenus[dynamicSubMenuID], @prefs);		DrawMenuBar;	END;	PROCEDURE Cleanup;	{ loop through all of the menus and release them from memory }		VAR			index: integer;	BEGIN		FOR index := firstMenu TO lastLoadedMenu DO	{ loop for all menus in menu bar}			BEGIN				DeleteMenu(index);				ReleaseResource(Handle(normalMenus[index]));			END;		FOR index := firstHierMenu TO lastHierMenu DO	{ loop for all menus in menu bar}			BEGIN				DeleteMenu(index);				ReleaseResource(Handle(hierMenus[index]));			END;	END;	{------------------------------- Main Program Seg ------------------------------}BEGIN	theErr := RegisterAppearanceClient();		MaxApplZone;	InitGraf(@qd.thePort);	InitFonts;	InitWindows;	InitMenus;	TEInit;	InitDialogs(NIL);	InitCursor;		SetUpMenus;			Finished := false;		MainEventLoop;	Cleanup;END.